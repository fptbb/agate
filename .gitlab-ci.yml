workflow:
  rules:
    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS && $CI_PIPELINE_SOURCE == "push"
      when: never
    - if: "$CI_COMMIT_TAG"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: "$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS"
      when: never
    - if: "$CI_COMMIT_BRANCH"
    # Daily Builds
    - if: $CI_PIPELINE_SOURCE == "schedule"

stages:
  - build
  - cleanup

build-image:
  stage: build
  tags:
    - saas-linux-2xlarge-amd64
  image:
    name: ghcr.io/blue-build/cli
    entrypoint: [""]
  services:
    - docker:dind
  parallel:
    matrix:
      - RECIPE:
          - recipe.yml
  variables:
    # Setup a secure connection with docker-in-docker service
    # https://docs.gitlab.com/ee/ci/docker/using_docker_build.html
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: /certs
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: $DOCKER_TLS_CERTDIR/client
  before_script:
    # Pulls secure files into the build
    - curl --silent "https://gitlab.com/gitlab-org/incubation-engineering/mobile-devops/download-secure-files/-/raw/main/installer" | bash
    - export COSIGN_PRIVATE_KEY=$(cat .secure_files/cosign.key)
    - docker login $BB_REGISTRY -u $BB_USERNAME -p $BB_PASSWORD
  script:
    - sleep 5 # Wait a bit for the docker-in-docker service to start
    - echo "Pushing to $BB_REGISTRY/$BB_REGISTRY_NAMESPACE/agate"
    - bluebuild build --verbose --cache-layers --compression-format zstd --push ./recipes/$RECIPE

cleanup-old-tags:
  stage: cleanup
  image: python:3-alpine
  variables:
    IMAGE_NAME: agate
    MAX_AGE_DAYS: "7"
    MAX_KEEP: "5"
    DRY_RUN: "false"
  script:
    - pip install requests
    - |
      python3 -c '
      import os
      import sys
      import time
      import logging
      import requests
      import email.utils
      from datetime import datetime, timezone

      # Configure logging
      logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
      logger = logging.getLogger(__name__)

      class QuayExpirationSetter:
          def __init__(self):
              self.registry = os.environ.get("BB_REGISTRY", "quay.io")
              self.namespace = os.environ.get("BB_REGISTRY_NAMESPACE")
              self.repository = os.environ.get("IMAGE_NAME")
              self.username = os.environ.get("BB_USERNAME")
              self.token = os.environ.get("BB_PASSWORD")
              self.dry_run = os.environ.get("DRY_RUN", "false").lower() == "true"
              
              if not all([self.namespace, self.repository, self.token]):
                  logger.error("Missing variables.")
                  sys.exit(1)

              self.base_url = f"https://{self.registry}"
              self.session = requests.Session()
              
              # Using Bearer Auth (Standard for Quay Robots)
              self.session.headers.update({
                  "Authorization": f"Bearer {self.token}",
                  "Content-Type": "application/json"
              })

          def get_image_tags(self):
              try:
                  url = f"{self.base_url}/api/v1/repository/{self.namespace}/{self.repository}/tag/"
                  params = {"limit": 100, "page": 1}
                  all_tags = []
                  
                  while True:
                      response = self.session.get(url, params=params, timeout=30)
                      response.raise_for_status()
                      data = response.json()
                      tags = data.get("tags", [])
                      if not tags: break
                      all_tags.extend(tags)
                      if not data.get("has_additional", False): break
                      params["page"] += 1
                  
                  return all_tags
              except Exception as e:
                  logger.error(f"Failed to get tags: {e}")
                  return []

          def expire_tag(self, tag):
              """Sets the expiration of a tag to NOW, prompting GC to clean it."""
              if self.dry_run:
                  logger.info(f"[DRY RUN] Would set expiration for {tag}")
                  return True
              
              try:
                  # Quay API: PUT /tag/{tag}/expiration
                  url = f"{self.base_url}/api/v1/repository/{self.namespace}/{self.repository}/tag/{tag}/expiration"
                  
                  # Set expiration to current time (effectively expires immediately)
                  expiration_timestamp = int(time.time())
                  payload = {"expiration": expiration_timestamp}
                  
                  response = self.session.put(url, json=payload, timeout=30)
                  
                  if response.status_code == 403:
                      logger.error(f"403 Forbidden setting expiration for {tag}.")
                      return False
                      
                  response.raise_for_status()
                  logger.info(f"Successfully set expiration for {tag}")
                  return True
              except Exception as e:
                  logger.error(f"Failed to expire {tag}: {e}")
                  return False

          def parse_timestamp(self, timestamp_raw):
              try:
                  if isinstance(timestamp_raw, (int, float)):
                      return datetime.fromtimestamp(timestamp_raw, tz=timezone.utc)
                  try:
                      return datetime.fromtimestamp(int(timestamp_raw), tz=timezone.utc)
                  except ValueError:
                      pass
                  dt = email.utils.parsedate_to_datetime(timestamp_raw)
                  if dt.tzinfo is None: dt = dt.replace(tzinfo=timezone.utc)
                  return dt
              except:
                  return None

          def run(self):
              max_age_days = int(os.environ.get("MAX_AGE_DAYS", 7))
              max_keep = int(os.environ.get("MAX_KEEP", 5))
              
              logger.info(f"Starting Expiration Scan: Max Age={max_age_days}d, Min Keep={max_keep}")
              tags = self.get_image_tags()
              
              # Add parsed dates
              for tag in tags:
                  tag["parsed_date"] = self.parse_timestamp(tag.get("last_modified"))

              # Sort newest first
              tags_sorted = sorted(
                  tags, 
                  key=lambda t: t["parsed_date"] or datetime.min.replace(tzinfo=timezone.utc), 
                  reverse=True
              )
              
              kept_count = 0
              for tag in tags_sorted:
                  tag_name = tag.get("name", "")
                  tag_date = tag.get("parsed_date")

                  # Skip 'latest' and the newest N tags
                  if tag_name == "latest" or kept_count < max_keep:
                      logger.info(f"Skipping {tag_name} (protected/recent)")
                      kept_count += 1
                      continue

                  # Check age
                  if tag_date:
                      age_days = (datetime.now(timezone.utc) - tag_date).days
                      if age_days > max_age_days:
                          self.expire_tag(tag_name)
                          continue
                  
                  logger.info(f"Skipping {tag_name} (not expired)")

      if __name__ == "__main__":
          cleaner = QuayExpirationSetter()
          cleaner.run()
      '